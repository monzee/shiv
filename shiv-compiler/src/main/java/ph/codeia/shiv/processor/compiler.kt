package ph.codeia.shiv.processor

import com.squareup.javapoet.ClassName
import com.squareup.javapoet.TypeName
import javax.annotation.processing.Messager
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.element.Element
import javax.lang.model.type.TypeMirror
import javax.lang.model.util.Elements
import javax.lang.model.util.Types


/*
 * This file is a part of the Shiv project.
 */

const val SIGNATURE = "Generated by Shiv (https://github.com/monzee/shiv)"
const val INJECT = "javax.inject.Inject"
const val FRAGMENT = "androidx.fragment.app.Fragment"
const val VIEW_MODEL = "androidx.lifecycle.ViewModel"
const val VIEW_MODEL_FACTORY = "androidx.lifecycle.ViewModelProvider.Factory"
const val LATE_BOUND = "ph.codeia.shiv.LateBound"
const val SAVED_STATE_HANDLE = "androidx.lifecycle.SavedStateHandle"


object Names {
	val MODULE = ClassName.get("dagger", "Module")
	val BINDS = ClassName.get("dagger", "Binds")
	val PROVIDES = ClassName.get("dagger", "Provides")
	val INTO_MAP = ClassName.get("dagger.multibindings", "IntoMap")
	val CLASS_KEY = ClassName.get("dagger.multibindings", "ClassKey")
	val STRING_KEY = ClassName.get("dagger.multibindings", "StringKey")
	val INJECT = ClassName.get("javax.inject", "Inject")
	val PROVIDER = ClassName.get("javax.inject", "Provider")
	val SHARED = ClassName.get("ph.codeia.shiv", "Shared")
	val SHIV = ClassName.get("ph.codeia.shiv", "Shiv")
	val SAVED_STATE_HANDLE_HOLDER = ClassName.get("ph.codeia.shiv", "SavedStateHandleHolder")
	val VIEW_MODEL_PROVIDER = ClassName.get("androidx.lifecycle", "ViewModelProvider")
	val VIEW_MODEL_STORE_OWNER = ClassName.get("androidx.lifecycle", "ViewModelStoreOwner")
}


class ProcessingContext(processingEnv: ProcessingEnvironment) :
	Elements by processingEnv.elementUtils,
	Types by processingEnv.typeUtils,
	Messager by processingEnv.messager
{
	val filer = processingEnv.filer

	infix fun Element.extends(superType: String): Boolean = let {
		getTypeElement(superType)?.let { typeElem ->
			it extends typeElem
		} ?: false
	}

	infix fun Element.extends(superType: Element): Boolean = let {
		it.asType() extends superType.asType()
	}

	infix fun TypeMirror.extends(superType: String): Boolean = let {
		getTypeElement(superType)?.let { typeElem ->
			it extends typeElem.asType()
		} ?: false
	}

	infix fun TypeMirror.extends(superType: TypeMirror): Boolean = let {
		isSubtype(it, superType)
	}

	fun typeNameOf(fqcn: String): TypeName = TypeName.get(getTypeElement(fqcn).asType())
}
